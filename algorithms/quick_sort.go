package main

import (
	"fmt"
)

// Разделение (Partition): Функция partition переупорядочивает массив таким образом, что все элементы, меньшие опорного,
// оказываются слева от него, а все большие или равные – справа. В конце, опорный элемент помещается
// между этими двумя подмассивами.
func partition(arr []int, low, high int) int {
	pivot := arr[high] // выбираем крайний правый элемент в качестве опорного
	i := low           // индекс меньшего элемента

	for j := low; j < high; j++ {
		// Если текущий элемент меньше или равен опорному
		if arr[j] <= pivot {
			arr[i], arr[j] = arr[j], arr[i]
			i++ // сдвигаем индекс меньшего элемента
		}
	}
	arr[i], arr[high] = arr[high], arr[i]
	return i
}

// Описание алгоритма:
// Выбор опорного элемента: Выбирается элемент, относительно которого будет производиться разделение.
// В приведённом выше примере в качестве опорного выбирается крайний правый элемент массива.

// Рекурсивная сортировка: После того как partition выполнена, опорный элемент находится на своем итоговом месте в
// массиве. Далее, алгоритм рекурсивно применяется к подмассивам слева и справа от опорного элемента.
// Эти шаги повторяются до тех пор, пока не будут отсортированы все подмассивы.
//
// Быстрая сортировка работает эффективно для больших массивов и, в среднем, имеет временную сложность O(n log n),
// где n - количество элементов в массиве. Однако в худшем случае её сложность может достигать O(n^2), что случается,
// когда каждый раз выбирается наихудший опорный элемент (например, при сортировке уже отсортированного массива).
// quickSort рекурсивно сортирует элементы до и после опорного
func quickSort(arr []int, low, high int) {
	if low < high {
		pivotIndex := partition(arr, low, high)

		quickSort(arr, low, pivotIndex-1)  // Перед опорным элементом
		quickSort(arr, pivotIndex+1, high) // После опорного элемента
	}
}

// Алгоритм быстрой сортировки (quicksort) является эффективным алгоритмом сортировки,
// использующим стратегию "разделяй и властвуй". Алгоритм выбирает элемент, который называется "опорным", и
// переупорядочивает массив таким образом, что все элементы, меньшие опорного, перемещаются перед ним, а все большие -
// следуют за ним. Таким образом, опорный элемент встаёт на своё итоговое место в отсортированной последовательности.
// Затем алгоритм рекурсивно применяется к подмассивам слева и справа от опорного элемента.
func main() {
	arr := []int{10, 80, 30, 90, 40, 50, 70}
	fmt.Println("Исходный массив:", arr)
	quickSort(arr, 0, len(arr)-1)
	fmt.Println("Отсортированный массив:", arr)
}
