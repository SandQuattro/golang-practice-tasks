package main

import "fmt"

// BinarySearch выполняет бинарный поиск числа target в отсортированном срезе nums.
// Возвращает индекс найденного числа или -1, если число не найдено.

// BinarySearch Описание алгоритма
// Бинарный поиск – это эффективный алгоритм поиска, который используется для нахождения элемента в отсортированном массиве
// или списке. Принцип работы алгоритма основан на делении диапазона поиска пополам и последующем сравнении искомого значения ]
// с элементом в середине диапазона. В зависимости от результата сравнения, алгоритм либо находит искомый элемент,
// либо продолжает поиск в левой или правой половине диапазона. Данный метод намного быстрее линейного поиска,
// особенно для больших массивов, так как количество сравниваемых элементов уменьшается экспоненциально на каждом шаге.
//
// Шаги алгоритма бинарного поиска:
// Инициализация границ: Определяются начальные границы диапазона поиска, обычно это начало (left) и конец (right) массива.
//
// Нахождение середины диапазона: Вычисляется индекс среднего элемента. Он может быть найден как (left + right) / 2.
// Однако, для предотвращения возможного переполнения при вычислении среднего на языках программирования с фиксированным
// размером числовых типов используется формула left + (right - left) / 2.
//
// Сравнение среднего элемента с искомым значением: есть три возможных случая:
//
// Средний элемент равен искомому: поиск успешно завершен.
// Средний элемент меньше искомого: искомое значение должно находиться в правой половине диапазона. Таким образом,
// изменяется начальная граница left на middle + 1, и поиск продолжается.
// Средний элемент больше искомого: искомое значение должно находиться в левой половине диапазона. В этом случае,
// конечная граница right изменяется на middle - 1, и поиск продолжается.
// Повторение процесса: шаги 2 и 3 повторяются до тех пор, пока left не станет больше right, или пока не будет найдено
// искомое значение.
//
// Обработка результатов поиска: Если элемент найден, возвращается его индекс. Если элемент отсутствует, можно вернуть
// индекс, по которому элемент мог бы быть вставлен, сохраняя порядок сортировки массива, или специальное значение (например, -1), указывающее на отсутствие элемента.
//
// Преимущества бинарного поиска:
// Эффективность: В худшем случае время выполнения составляет O(log n), где n — размер массива. Это делает бинарный
// поиск значительно быстрее линейного поиска (O(n)), особенно для больших наборов данных.
// Простота реализации: Алгоритм достаточно прост для понимания и реализации.
// Ограничения:

// !! Требование к данным: Массив или список должен быть отсортирован по возрастанию или убыванию перед применением
// алгоритма бинарного поиска.

// Статичность массива: Для эффективного применения бинарного поиска данные не должны часто изменяться, так как каждое
// изменение порядка элементов потребует повторной сортировки.
func BinarySearch(nums []int, target int) int {
	left, right := 0, len(nums)-1
	for left <= right {
		middle := left + (right-left)/2 // Предотвращаем возможное переполнение
		if nums[middle] == target {
			return middle // Нашли число, возвращаем индекс
		}
		if nums[middle] < target {
			left = middle + 1 // Ищем справа
		} else {
			right = middle - 1 // Ищем слева
		}
	}
	return -1 // Число не найдено
}

func main() {
	// массив отсортирован!!
	nums := []int{-5, 1, 3, 6, 8, 12, 20}
	target := 8

	pos := BinarySearch(nums, target)

	if pos != -1 {
		fmt.Printf("Число %d найдено на %dй позиции.\n", target, pos+1)
	} else {
		fmt.Printf("Число %d не найдено.\n", target)
	}
}
